(ns power-turtle.lang.korean)

(defmacro 배열을얻을 [& body]
  "기능
  사용법 : (배열을얻을 배열 IDX)
  (배열을얻을 배열 IDX & idxs)
  인덱스 / 인덱스의 값을 돌려줍니다.  모든 자바 배열에서 작동
  유형."
  `(aget ~@body))

(defmacro 과 [& body]
  "사용법 : (과)
  (그리고 배)
  (x는 다음과)
  왼쪽에서 오른쪽으로 한번에 하나씩 exprs을 평가한다.  양식의 경우
  논리적 오류 (전무 또는 false)을 반환하고 그 값을 반환하고
  그렇지 않으면 반환, 다른 식의 어떤을 평가하지 않습니다
  마지막 EXPR의 값입니다.  (과)는 true를 돌려줍니다."
  `(and ~@body))

(defmacro 대다 [& body]
  "사용법 : (F 인수를 적용)
  (FX 인자들을 적용)
  (FXY 인수를 적용)
  (fxyz 인수를 적용)
  (fabcd 및 인수를 적용)
  인수에 개입 인수를 앞에 추가에 의해 형성되는 인수 목록에 f를 fn을 적용합니다."
  `(apply ~@body))

(defmacro 세트 [& body]
  "사용법 : (세트 배열 IDX의 발)
  (세트 배열 IDX idx2 & idxv)
  인덱스 / 인덱스의 값을 설정합니다.  자바 배열에서 작동
  참조 유형.  발 돌려줍니다."
  `(aset ~@body))

(defmacro 동무 [& body]
  "사용법 : (동무 지도 키 발)
  (동무 지도 키 발 & KVS)
  동무.  맵에 적용될 때, 새로운 맵을 돌려
  같은 (​​해시 / 분류)에 키 (들)의 매핑을 포함하는 입력
  발 (들).  벡터에 적용하면, 새로운 벡터를 반환
  발은 인덱스에 포함되어 있습니다.  주 - 인덱스가 있어야합니다 <= (벡터 계산)."
  `(assoc ~@body))

(defmacro 에연결 [& body]
  "사용법 : (에연결 m [K & KS] V)
  KS가있는 중첩 된 결합 구조의 동료 값을
  키와 V의 순서는 새 값이고 새로운 중첩 된 구조를 반환합니다.
  모든 레벨이 존재하지 않는 경우, 해시 맵이 생성된다."
  `(assoc-in ~@body))

;; got bored


(defmacro 밝히다 [& body]
  "사용법 : (데프 기호 문서 문자열 초기화?)
  이름의 글로벌 VAR를 작성 및 인턴
  현재 네임 스페이스의 기호 (* NS *) 또는 이러한 VAR 경우를 찾습니다
  그것은 이미 존재합니다.  INIT가 공급되는 경우, 평가하고있다
  var에 결합 루트 얻어진 값으로 설정된다.  INIT는이면
  제공되지는 VAR의 결합 루트는 영향을받지 않습니다."
  `(def ~@body))

(defmacro 함수를정의 [& body]
  "사용법 : (함수를정의 이름의 문서 문자열 맵 [PARAMS *] Prepost에서-지도 본체)
         (함수를정의 이름의 문서 문자열 맵 ([PARAMS *] Prepost에서-지도? 본체) + ATTR-지도?)
  동일로 (데프 이름 (기능 [PARAMS *] exprs *)) 또는 (밝히다
                                           추가 된 모든 문서 문자열 또는 attrs에와 이름 (기능 ([PARAMS *] exprs *) +))
  var에 메타 데이터.  Prepost에서-지도는 선택 키 맵을 정의
  : 이전과 : 사전 또는 사후 조건의 컬렉션을 포함 게시 할 수 있습니다."
  `(defn ~@body))

(defmacro 만약 [& body]
  "사용법 : (만약 테스트 그때 그밖에)
  테스트를 평가합니다.  아닌 특이 값이 존재하지 않거나 false의 경우,
  그렇지 않으면, 평가하고 다른 수익률, 평가 후 수익률.  만약
  다른 그것을 전무 디폴트는 제공되지 않습니다."
  `(if ~@body))

;; all
(defmacro 모든 [& body]
  `(fn [] ~@body))

(defmacro 기능 [& body]
  "사용법 : (기능 이름 [PARAMS *] exprs *)
  (기능 이름은? ([PARAMS *] exprs *) +)
  PARAMS => 위치-PARAMS의 *, 또는 위치-PARAMS의 * 다음-PARAM
  위치-PARAM => 결합 형태
  다음-PARAM => 결합 형태
  이름 => 기호

  함수를 정의"
  `(fn ~@body))

(defmacro 자꾸 [& body]
  "사용법 : (반복 F)
  (반복 N F)
  아마도 부작용없이 인수의 함수를 취득하고,
  (제공 N 경우 또는 길이) 무한 통화의 게으른 시퀀스를 반환
  그것"
  `(repeatedly ~@body))

(defmacro 방해 [& body]
  "사용법 : (방해 [제본*] 식*)
  바인딩 => 결합 형태 초기화-EXPR

  어휘 맥락에서 exprs을 평가하는 기호에
  바인딩-형태는 각각의 초기화 - exprs 또는 부품에 바인딩
  내부."
  `(let ~@body))
